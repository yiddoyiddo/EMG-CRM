import { startOfWeek, endOfWeek, startOfMonth, endOfMonth, subWeeks, subMonths, format, addDays, subDays, startOfQuarter, endOfQuarter } from 'date-fns';

// Re-export functions from new modules for backward compatibility
export { 
  detectAutomaticCallCompletions, 
  getAllCallCompletions 
} from './reporting/call-analytics';

export { 
  calculateKPIs 
} from './reporting/kpi-calculator';

// Import functions we need internally
import { getAllCallCompletions } from './reporting/call-analytics';


export function calculateTeamPerformance(pipelineItems: any[], activityLogs: any[], financeEntries: any[] = []) {
  // Get unique BDRs from the provided data
  const bdrSet = new Set<string>();
  pipelineItems.forEach(item => item.bdr && bdrSet.add(item.bdr));
  activityLogs.forEach(log => log.bdr && bdrSet.add(log.bdr));
  financeEntries.forEach(entry => entry.bdr && bdrSet.add(entry.bdr));
  
  const allBDRs = Array.from(bdrSet);
  
  const activeBDRs = allBDRs.filter(bdr => {
    const recentActivity = activityLogs.filter(log => 
      log.bdr === bdr && 
      log.timestamp >= subDays(new Date(), 7)
    );
    return recentActivity.length > 0;
  });
  
  // Calculate individual BDR performance
  const bdrPerformance = allBDRs.map(bdr => {
    const bdrItems = pipelineItems.filter(item => item.bdr === bdr);
    const bdrActivities = activityLogs.filter(log => log.bdr === bdr);
    const bdrFinanceEntries = financeEntries.filter(entry => entry.bdr === bdr);
    
    // Use enhanced call completion logic for BDR performance
    const allCallCompletions = getAllCallCompletions(pipelineItems, activityLogs, new Date(0), new Date());
    const bdrCallCompletions = allCallCompletions.filter(completion => completion.bdr === bdr);
    const calls = bdrCallCompletions.length;
    
    const agreements = bdrActivities.filter(log => log.activityType === 'Agreement_Sent').length;
    const lists = bdrActivities.filter(log => log.activityType === 'Partner_List_Sent').length;
    // Count all sales generated by this BDR
    const sales = bdrFinanceEntries.length;
    
    const score = calls * 1 + agreements * 3 + lists * 2 + sales * 5;
    
    return { bdr, score, calls, agreements, lists, sales };
  });
  
  // Sort by performance score
  bdrPerformance.sort((a, b) => b.score - a.score);
  
  const topPerformers = bdrPerformance.slice(0, 3).map(p => p.bdr);
  const needsSupport = bdrPerformance.filter(p => p.score < 10 && p.calls < 5).map(p => p.bdr);
  
  // Calculate benchmark metrics using enhanced call completion logic
  const allCallCompletions = getAllCallCompletions(pipelineItems, activityLogs, new Date(0), new Date());
  const totalCalls = allCallCompletions.length;
  const totalAgreements = activityLogs.filter(log => log.activityType === 'Agreement_Sent').length;
  const totalLists = activityLogs.filter(log => log.activityType === 'Partner_List_Sent').length;
  // Count all sales generated
  const totalSales = financeEntries.length;
  
  return {
    totalBDRs: allBDRs.length,
    activeBDRs: activeBDRs.length,
    topPerformers,
    needsSupport,
    benchmarkMetrics: {
      avgCallsPerWeek: allBDRs.length > 0 ? Math.round((totalCalls / allBDRs.length) * 10) / 10 : 0,
      avgAgreementsPerMonth: allBDRs.length > 0 ? Math.round((totalAgreements / allBDRs.length) * 10) / 10 : 0,
      avgListsPerMonth: allBDRs.length > 0 ? Math.round((totalLists / allBDRs.length) * 10) / 10 : 0,
      teamConversionRate: totalCalls > 0 ? Math.round((totalSales / totalCalls) * 100 * 100) / 100 : 0
    }
  };
}

export function assessPipelineHealth(pipelineItems: any[], activityLogs: any[], currentDate: Date, financeEntries: any[] = []) {
  const now = currentDate;
  const nextWeekEnd = endOfWeek(addDays(now, 7), { weekStartsOn: 1 });
  const next2WeeksEnd = endOfWeek(addDays(now, 14), { weekStartsOn: 1 });
  
  // Upcoming calls
  const upcomingCallsNextWeek = pipelineItems.filter(item => 
    item.callDate && item.callDate > now && item.callDate <= nextWeekEnd
  ).length;
  
  const upcomingCallsNext2Weeks = pipelineItems.filter(item => 
    item.callDate && item.callDate > nextWeekEnd && item.callDate <= next2WeeksEnd
  ).length;
  
  const totalUpcomingCalls = pipelineItems.filter(item => 
    item.callDate && item.callDate > now
  ).length;
  
  // Pending agreements
  const proposalsAwaitingResponse = pipelineItems.filter(item => 
    item.status && item.status.includes('Proposal') && !item.status.includes('Agreement')
  ).length;
  
  const agreementsAwaitingLists = pipelineItems.filter(item => 
    item.status && item.status.includes('Agreement') && !item.partnerListSentDate
  ).length;
  
  const overduePartnerLists = pipelineItems.filter(item => 
    item.expectedCloseDate && item.expectedCloseDate < now && 
    !item.partnerListSentDate && item.status && item.status.includes('Agreement')
  ).length;
  
  // Active lists out
  const activeListsTotal = pipelineItems.filter(item => 
    item.partnerListSentDate && 
    !['Sold', 'List Out - Not Sold', 'Free Q&A Offered'].includes(item.status || '')
  ).length;
  
  const activeLists = pipelineItems.filter(item => 
    item.partnerListSentDate && item.partnerListSize &&
    !['Sold', 'List Out - Not Sold', 'Free Q&A Offered'].includes(item.status || '')
  );
  
  const smallLists = activeLists.filter(item => item.partnerListSize! >= 3 && item.partnerListSize! <= 8).length;
  const mediumLists = activeLists.filter(item => item.partnerListSize! >= 9 && item.partnerListSize! <= 15).length;
  const largeLists = activeLists.filter(item => item.partnerListSize! >= 16).length;
  
  const averageListSize = activeLists.length > 0 ? 
    activeLists.reduce((sum, item) => sum + (item.partnerListSize || 0), 0) / activeLists.length : 0;
  
  // Conversion funnel - use enhanced call completion logic
  const callsBooked = pipelineItems.filter(item => 
    item.category === 'Calls' && item.status === 'Call Booked'
  ).length;
  
  const allCallCompletions = getAllCallCompletions(pipelineItems, activityLogs, new Date(0), new Date());
  const callsConducted = allCallCompletions.length;
  
  const proposalsSent = activityLogs.filter(log => 
    log.activityType === 'Proposal_Sent'
  ).length;
  
  const agreementsSigned = activityLogs.filter(log => 
    log.activityType === 'Agreement_Sent'
  ).length;
  
  const listsSent = activityLogs.filter(log => 
    log.activityType === 'Partner_List_Sent'
  ).length;
  
  // Count all sales generated, regardless of payment status
  const salesGenerated = financeEntries.length;
  
  return {
    upcomingCalls: {
      nextWeek: upcomingCallsNextWeek,
      next2Weeks: upcomingCallsNext2Weeks,
      total: totalUpcomingCalls
    },
    pendingAgreements: {
      proposalsAwaitingResponse,
      agreementsAwaitingLists,
      overduePartnerLists
    },
    activeListsOut: {
      total: activeListsTotal,
      smallLists,
      mediumLists,
      largeLists,
      averageListSize: Math.round(averageListSize * 10) / 10
    },
    conversionFunnel: {
      callsBooked,
      callsConducted,
      proposalsSent,
      agreementsSigned,
      listsSent,
      salesGenerated
    }
  };
}

export function calculateTrends(pipelineItems: any[], activityLogs: any[], currentDate: Date, financeEntries: any[] = []) {
  const now = currentDate;
  
  // Weekly call volume trend (last 4 weeks) - use enhanced call completion logic
  const weeklyCallVolume = [];
  for (let i = 3; i >= 0; i--) {
    const weekStart = startOfWeek(subWeeks(now, i), { weekStartsOn: 1 });
    const weekEnd = endOfWeek(subWeeks(now, i), { weekStartsOn: 1 });
    
    const callCompletions = getAllCallCompletions(pipelineItems, activityLogs, weekStart, weekEnd);
    const calls = callCompletions.length;
    
    const target = 40; // Target calls per week
    const variance = ((calls - target) / target) * 100;
    
    weeklyCallVolume.push({
      week: format(weekStart, 'MMM dd'),
      calls,
      target,
      variance: Math.round(variance)
    });
  }
  
  // Monthly agreements trend (last 4 months)
  const monthlyAgreements = [];
  for (let i = 3; i >= 0; i--) {
    const monthStart = startOfMonth(subMonths(now, i));
    const monthEnd = endOfMonth(subMonths(now, i));
    
    const agreements = activityLogs.filter(log => 
      log.activityType === 'Agreement_Sent' && 
      log.timestamp >= monthStart && log.timestamp <= monthEnd
    ).length;
    
    const target = 20; // Target agreements per month
    const variance = ((agreements - target) / target) * 100;
    
    monthlyAgreements.push({
      month: format(monthStart, 'MMM yyyy'),
      agreements,
      target,
      variance: Math.round(variance)
    });
  }
  
  // Quarterly lists out trend (current and previous quarters) - use finance entries for sales data
  const quarterlyListsOut = [];
  for (let i = 1; i >= 0; i--) {
    const quarterStart = startOfQuarter(subMonths(now, i * 3));
    const quarterEnd = endOfQuarter(subMonths(now, i * 3));
    
    const lists = activityLogs.filter(log => 
      log.activityType === 'Partner_List_Sent' && 
      log.timestamp >= quarterStart && log.timestamp <= quarterEnd
    ).length;
    
    // Count all sales generated in the quarter
    const quarterSales = financeEntries.filter(entry => 
      entry.createdAt >= quarterStart && entry.createdAt <= quarterEnd
    );
    const conversions = quarterSales.length;
    
    const revenue = quarterSales.reduce((sum, entry) => sum + (entry.gbpAmount || 0), 0);
    
    quarterlyListsOut.push({
      quarter: `Q${Math.floor((quarterStart.getMonth()) / 3) + 1} ${quarterStart.getFullYear()}`,
      lists,
      conversions,
      revenue
    });
  }
  
  return {
    weeklyCallVolume,
    monthlyAgreements,
    quarterlyListsOut
  };
}

export function identifyCriticalActions(pipelineItems: any[], activityLogs: any[], teamPerformance: any, currentDate: Date): Array<{
  priority: 'urgent' | 'high' | 'medium';
  category: 'calls' | 'agreements' | 'lists' | 'team';
  action: string;
  assignedTo?: string;
  metric?: number;
  deadline?: string;
}> {
  const actions: Array<{
    priority: 'urgent' | 'high' | 'medium';
    category: 'calls' | 'agreements' | 'lists' | 'team';
    action: string;
    assignedTo?: string;
    metric?: number;
    deadline?: string;
  }> = [];
  const now = currentDate;
  
  // Check for overdue partner lists
  const overdueCount = pipelineItems.filter(item => 
    item.expectedCloseDate && item.expectedCloseDate < now && 
    !item.partnerListSentDate && item.status && item.status.includes('Agreement')
  ).length;
  
  if (overdueCount > 0) {
    actions.push({
      priority: 'urgent' as const,
      category: 'lists' as const,
      action: `Send ${overdueCount} overdue partner lists immediately`,
      metric: overdueCount,
      deadline: 'Today'
    });
  }
  
  // Check for low call volume - use enhanced call completion logic
  const thisWeekCallCompletions = getAllCallCompletions(pipelineItems, activityLogs, startOfWeek(now, { weekStartsOn: 1 }), now);
  const thisWeekCalls = thisWeekCallCompletions.length;
  
  if (thisWeekCalls < 25) {
    actions.push({
      priority: 'high' as const,
      category: 'calls' as const,
      action: 'Boost call volume - current week significantly below target',
      metric: thisWeekCalls,
      deadline: 'End of week'
    });
  }
  
  // Check for team members needing support
  if (teamPerformance.needsSupport.length > 0) {
    actions.push({
      priority: 'medium' as const,
      category: 'team' as const,
      action: `Provide support to underperforming BDRs: ${teamPerformance.needsSupport.join(', ')}`,
      metric: teamPerformance.needsSupport.length,
      deadline: 'This week'
    });
  }
  
  // Check for upcoming calls without enough pipeline
  const upcomingCalls = pipelineItems.filter(item => 
    item.callDate && item.callDate > now && item.callDate <= addDays(now, 7)
  ).length;
  
  if (upcomingCalls < 30) {
    actions.push({
      priority: 'high' as const,
      category: 'calls' as const,
      action: 'Schedule more calls for next week to maintain pipeline',
      metric: upcomingCalls,
      deadline: 'End of week'
    });
  }
  
  return actions.sort((a, b) => {
    const priorityOrder = { urgent: 3, high: 2, medium: 1 };
    return priorityOrder[b.priority] - priorityOrder[a.priority];
  });
}

export function calculateFinancialSummary(pipelineItems: any[], activityLogs: any[], currentDate: Date, financeEntries: any[] = []) {
  const now = currentDate;
  const thisMonthStart = startOfMonth(now);
  const thisQuarterStart = startOfQuarter(now);
  
  // Use all finance entries for revenue calculations
  const monthlyRevenue = financeEntries
    .filter(entry => entry.createdAt >= thisMonthStart)
    .reduce((sum, entry) => sum + (entry.gbpAmount || 0), 0);
  
  const quarterlyRevenue = financeEntries
    .filter(entry => entry.createdAt >= thisQuarterStart)
    .reduce((sum, entry) => sum + (entry.gbpAmount || 0), 0);
  
  const totalRevenue = financeEntries.reduce((sum, entry) => sum + (entry.gbpAmount || 0), 0);
  
  const activeBDRs = Array.from(new Set(pipelineItems.map(item => item.bdr).filter(Boolean))).length;
  
  // Use enhanced call completion logic for financial metrics
  const allCallCompletions = getAllCallCompletions(pipelineItems, activityLogs, new Date(0), new Date());
  const totalCalls = allCallCompletions.length;
  
  const totalLists = activityLogs.filter(log => log.activityType === 'Partner_List_Sent').length;
  
  return {
    monthlyRevenue,
    quarterlyRevenue,
    revenuePerBDR: activeBDRs > 0 ? Math.round(totalRevenue / activeBDRs) : 0,
    revenuePerCall: totalCalls > 0 ? Math.round(totalRevenue / totalCalls) : 0,
    revenuePerList: totalLists > 0 ? Math.round(totalRevenue / totalLists) : 0,
    forecastAccuracy: 85 // Would require historical forecasting data to calculate
  };
}

export function generatePredictiveInsights(pipelineItems: any[], activityLogs: any[], trends: any, currentDate: Date) {
  const now = currentDate;
  
  // Simple predictions based on current trends
  const avgWeeklyCalls = trends.weeklyCallVolume.reduce((sum: number, week: any) => sum + week.calls, 0) / trends.weeklyCallVolume.length;
  const expectedCallsNextWeek = Math.round(avgWeeklyCalls * 1.1); // Slight optimistic projection
  
  const avgMonthlyAgreements = trends.monthlyAgreements.reduce((sum: number, month: any) => sum + month.agreements, 0) / trends.monthlyAgreements.length;
  const expectedAgreementsNextMonth = Math.round(avgMonthlyAgreements * 1.05);
  
  const avgQuarterlyRevenue = trends.quarterlyListsOut.reduce((sum: number, quarter: any) => sum + quarter.revenue, 0) / trends.quarterlyListsOut.length;
  const expectedRevenueNextQuarter = Math.round(avgQuarterlyRevenue * 1.1);
  
  // Risk factors
  const riskFactors = [];
  const lowCallWeeks = trends.weeklyCallVolume.filter((week: any) => week.calls < week.target * 0.8).length;
  if (lowCallWeeks > 1) {
    riskFactors.push('Declining call volume trend could impact future pipeline');
  }
  
  const upcomingCalls = pipelineItems.filter(item => 
    item.callDate && item.callDate > now && item.callDate <= addDays(now, 14)
  ).length;
  if (upcomingCalls < 40) {
    riskFactors.push('Insufficient upcoming calls scheduled for next 2 weeks');
  }
  
  // Opportunities
  const opportunities = [];
  const strongPerformers: { [key: string]: number } = {};
  const recentLogs = activityLogs.filter(log => log.timestamp >= subDays(now, 30));
  for (const log of recentLogs) {
    if (log.bdr) {
      strongPerformers[log.bdr] = (strongPerformers[log.bdr] || 0) + 1;
    }
  }
  
  const topBDR = Object.entries(strongPerformers).sort(([,a], [,b]) => b - a)[0];
  if (topBDR) {
    opportunities.push(`${topBDR[0]} showing strong activity - consider replicating their approach`);
  }
  
  return {
    expectedCallsNextWeek,
    expectedAgreementsNextMonth,
    expectedRevenueNextQuarter,
    riskFactors,
    opportunities
  };
}
